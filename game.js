// the main game loop, boilerplate code from Mary Cook

;(function() {
	var Game = function(canvasId) 
	{
		// alright this entire thing is borrowed heavily from Mary Cook so go look up her 
		// making space invaders in JS and HTML5... it's impressive to watch it be live coded.
		// still this is basic stuff. create a canvas and store all the pertinent functions for what
		// we're working on.
		//
		// P.S. i know block quotes exists I jsut like the way this looks.
		var canvas = document.getElementById(canvasId); 
		var screen = canvas.getContext('2d');
		var screenSize = {x: canvas.width, y: canvas.height};
		var gameSize = { x: 10000, y: 3000};
		
		this.level_reset_timer = -1;
		this.level_reset_flag = false;
		
		this.level_passed = false;
		this.level_passed_timer = 0;
		
		this.level_start = true;
		this.level_start_timer = 0;
		
		// we're gonna need this in the tick event.
		var self = this;
		this.load_ready = false;
		this.loaded = false;
		this.assets_loaded = false;
		this.start_loading = false;
		
		this.audio_Control = new audio_controller(canvas);
		
		
		// prepare XHTTP request to loade the level file generated by GMS2 (because I'm
		// too lazy to make a JS level builder.
		var xml_ref = new XMLHttpRequest();
		xml_ref.open("GET", 'Level1_1.json');
		xml_ref.overrideMimeType('application/json');
		// Once the JSON's loaded load it into the pertinent variables and set the flag for the tick event.
		xml_ref.onload = function(){
			//console.log("WTF");
			//console.log(self.level);
			self.level = JSON.parse(xml_ref.responseText);
			self.load_ready = true;
			gameSize.y = self.level.roomHeight;
			gameSize.x = self.level.roomWidth;
			
			//console.log(self.level);
		}
		//console.log(this.load_ready);
		xml_ref.onerror = function(){
			
			//console.log("You fail");
		};
		xml_ref.send();
		
		
		// The meat and potatoes of this beauty. dirived from Mary Cook's Space Invaders code
		// this is the main game loop handling the running of everything.
		var tick = function(){
			//once the JSON's been loaded doo the thing... only once though
			if(self.load_ready == true && self.loaded == false)
			{
				
				//console.log(self.load_ready);
				
				//create a camera object to control the view in the stage
				self.camera_control = new Camera_Controller(screen,screenSize,gameSize);
				
				// please be careful of the commented out code.
				// my code is a bit of a graveyard of failed ideas.
				
				//var testObj = new gameObject(500,2000);
		
		
				// Oh the tile handler is pretty awesome. It only uses a bunch of Vector2 objects 
				// that I use through out this code.
				self.tile_handler = new TileHandler;
				
				self.tile_handler.makeTiles(self.level);
				
				
				// our not-plumber
				self.player = new Player(128,500,128,256,self.audio_Control);
				
				// the ever important physic bodies array
				self.bodies = [];
				
				// load the array of not-Goombas into the bodies array
				var array_x = self.level.goombaX;
				var array_y = self.level.goombaY;
				//console.log(self.level.goombaX);
				array_length = array_x.length;
				//console.log(array_length);
				for (_i = 0;_i < array_length; _i++)
				{
					
					var x =	array_x[_i];
					var y = array_y[_i];
					//console.log(x);
					self.bodies.push(new Goomba(x,y));
				}
				
				// load the array of brick blocks into the bodies array.
				var array_x = self.level.brickX;
				var array_y = self.level.brickY;
				
				//console.log(self.level.brickX);
				array_length = array_x.length;
				//console.log(array_length);
				
				for (_i = 0;_i < array_length; _i++)
				{
					
					var x =	array_x[_i];
					var y = array_y[_i];
					//console.log(x);
					self.bodies.push(new Brick(x,y));
				}
				
				var array_x = self.level.coinX;
				var array_y = self.level.coinY;
				
				//console.log(self.level.coinX);
				array_length = array_x.length;
				//console.log(array_length);
				for (_i = 0;_i < array_length; _i++)
				{
					
					var x =	array_x[_i];
					var y = array_y[_i];
					//console.log(x);
					self.bodies.push(new Coin(x,y));
				}
				//hey look another one
				//self.bodies.push(new Goomba(900,100));
				
				
				var array_x = self.level.boxX;
				var array_y = self.level.boxY;
				var array_item = self.level.boxItem;
				//console.log(self.level.brickX);
				array_length = array_x.length;
				//console.log(array_length);
				for (_i = 0;_i < array_length; _i++)
				{
					
					var x =	array_x[_i];
					var y = array_y[_i];
					var item = array_item[_i];
					//console.log(x);
					self.bodies.push(new Block(x,y,item));
				}
				
				self.bodies.push(new PowerUp(900,100, "Star"));
				
				self.bodies.push(new FlagPole(self.level.flagX, self.level.flagY));
				
				
				//load the player and we're set.
				self.bodies.push(self.player);
				self.loaded = true;
				
			}else if(self.loaded == true && self.assets_loaded == false){
				// if the level is loaded in. then we're in game now. 
				// Update all objects and draw them.
				screen.fillStyle = "#000000";
				screen.fillRect(0,0,screenSize.x,screenSize.y);
				screen.fillStyle = "#FFFFFF";
				screen.font="45px Impact";
				if(self.start_loading == false){
					screen.fillText("Please Click to Continue" ,10,65);
					canvas.addEventListener('click', function(event) {
						self.start_loading = true;;
					}, false);
				} else {
					var ready = true;
					var number_of_items = 0;
					var max_items = self.bodies.length;
					for (var i = 0; i < self.bodies.length; i++)
					{
						var current_body = self.bodies[i];
						if(current_body.art_loaded == true) number_of_items++;
						//ready = current_body.art_loaded && ready;
					}
					if(number_of_items == max_items)self.assets_loaded = true;
					screen.fillText("Loading (" + number_of_items + "/" +max_items + ")" ,10,65);
					//console.log(self.player.art_loaded);
				}
			}
				
			else if(self.assets_loaded == true)
			{
				self.update();
				self.draw(screen,screenSize,gameSize);
				
				//console.log(self.load_ready);
			}
			// once called tick request the window to run a function (in this case itself) the next animation frame (1/60th of a second)
			// acting as an in game tick
			requestAnimationFrame(tick);
		};
		
		// and lastly after defining the function... call it starting this whole thing in motion.
		tick();
		
		
	}
	
	
	// the game prototype.
	Game.prototype = {
		
		// the update function 
		update: function() {
			
			
			// call the camera objects update and pas in the player so it follows it.
			this.camera_control.update(this.player);
			
			//this.player.update(this.tile_handler);
			
			// run through the objects in the bodies and update them passing in the tile handler so they
			// can check their collision with it.
			for(const obj of this.bodies){
				obj.update(this.tile_handler,this);
			}
			
			
			// create an array of values that we'll use later to delete bodies that need to be deleted.
			var delete_indexes = [];
			
			// Loop through the bodies array
			for(var i = 0; i < this.bodies.length; i++)
			{
				// loop through them again for every body in the bodies array
				for(var j = 0; j < this.bodies.length; j++){
					if(j != i){
						
						// set the local varable ret_Val to false and then
						// call check collision using the i-body while passing in the j-body
						var ret_val = false;
						ret_val = this.bodies[i].checkCollision(this.bodies[j]);
						
						// push the index of j onto the array so it can be deleted later
						if(ret_val == true){
							// if the array is empty push the value onto it.
							if(delete_indexes.length == 0)delete_indexes.push(j);
							else
							{
								// if not figure out where in the array you need to splice it in to keep the values sorted.
								var splice_index = -2;
								for(var k = 0; k < delete_indexes.length; k++)
								{
									
									if(delete_indexes[k] == j)break; // if this already exists in the delete array, break out of the loop.
									// if not remember the index that was first greater than the index that needs to be deleted.
									if(delete_indexes[k] < j)splice_index = k;
										
									
								}
								
								// if the splice is needed, splice j in at the saved index
								// otherwise push the value onto the array (at the end)
								if(splice_index != -2)
									delete_indexes.splice(splice_index,0,j);
								else 
									delete_indexes.unshift(j);
							}
						}
					}else
					{
						//if this is the same as the object, then check whether the object needs to delete itself.
						if(this.bodies[i].delete_self == true)
						{
							if(delete_indexes.length == 0)delete_indexes.push(i);
							else
							{
								// if not figure out where in the array you need to splice it in to keep the values sorted.
								var splice_index = -2;
								for(var k = 0; k < delete_indexes.length; k++)
								{
									
									if(delete_indexes[k] == i)break; // if this already exists in the delete array, break out of the loop.
									// if not remember the index that was first greater than the index that needs to be deleted.
									if(delete_indexes[k] < i)splice_index = k;
										
									
								}
								
								// if the splice is needed, splice i in at the saved index
								// otherwise push the value onto the array (at the end)
								if(splice_index != -2)
									delete_indexes.splice(splice_index,0,i);
								else 
									delete_indexes.unshift(i);
							}
						}
					}
				}
				
			}
			
			// use the powerful splice function to delete the bodies that are no longer needed.
			for(var i = 0;i < delete_indexes.length; i++)
			{
				this.bodies.splice(delete_indexes[i],1);
			}
			
			// if the player drops off the level, or runs out of HP 
			// start the level reset script
			if((this.player.position.y > this.level.roomHeight + 200) 
			|| this.player.player_health == 0){
				this.level_reset_flag = true;
				if(this.level_reset_timer == -1)this.level_reset_timer = 200;
			}
				
			// this is the actually code that resets the level, causing the bodies array to be flushed (effectively deleting everything)
			// then re loading it, as well as tellng the camera to snap to position.
			if(this.level_reset_timer >= 0)
			{
				this.level_reset_timer--;
				if(this.level_reset_timer == 100){
					this.bodiesReset();
					this.camera_control.camera_reset_flag = true;
				}
					
			}
			
			if(this.level_start == true)
			{
				this.level_start_timer++;
				if(this.level_start_timer >= 100)
				{
					this.level_start = false;
				}
				
			}
			
			if(this.level_passed == true){
				
				this.level_passed_timer++;
				if(this.level_passed_timer > 150 && this.level_passed_timer < 400){
					this.player.level_end_flag = true;
					if(this.player.xSpeed < 20)this.player.xSpeed += 1;
					if(this.level_passed_timer > 200 && this.player.ySpeed > -20)this.player.ySpeed -= 1;
				}
				else this.player.xSpeed = 0;
				
				if(this.level_passed_timer == 400){
					this.bodiesReset();
					this.camera_control.camera_reset_flag = true;
					this.player.level_end_flag = false;
				}
				if(this.level_passed_timer == 501){
					this.level_passed_timer = 0;
					this.level_passed = false;
					
				}
			}
			
		},
		
		// the draw function
		draw: function(screen,screenSize, gameSize){
			
			
			// these are prety self explanatory 
			this.camera_control.draw();
			this.tile_handler.draw(screen,screenSize,gameSize,this.camera_control);
			
			
			// really the entire draw event describes itself well
			for(const obj of this.bodies){
				obj.draw(screen, screenSize, this.camera_control);
			}
			
			if(this.level_reset_timer > 50 && this.level_reset_timer < 150)
			{
				var alpha_set = 0;
				if((this.level_reset_timer > 50 && this.level_reset_timer < 60)
					|| (this.level_reset_timer > 140 && this.level_reset_timer < 150))
					{
						if(this.level_reset_timer > 50 && this.level_reset_timer < 60){
							alpha_set = (this.level_reset_timer-50 )/10;
						}
						if(this.level_reset_timer > 140 && this.level_reset_timer < 150){
							alpha_set = (149-this.level_reset_timer )/10;
						}
						screen.globalAlpha = alpha_set;
					}
				screen.fillStyle = "#000000";
				screen.fillRect(0,0,screenSize.x,screenSize.y);
				screen.globalAlpha = 1.0;
			}
			
			if(this.level_start_timer < 100)
			{
				var alpha_set = 1;
				if(this.level_start_timer > 90 && this.level_start_timer < 100)
					{
						alpha_set = (100-this.level_start_timer )/10;
					
					screen.globalAlpha = alpha_set;
				}
			
				screen.fillStyle = "#000000";
				screen.fillRect(0,0,screenSize.x,screenSize.y);
				screen.globalAlpha = 1.0;
			}
			if(this.level_passed_timer > 250 && this.level_passed_timer < 500)
			{
				
				var alpha_set = 0;
				if((this.level_passed_timer > 250 && this.level_passed_timer < 260)
					|| (this.level_passed_timer > 490 && this.level_passed_timer < 500))
					{
						if(this.level_passed_timer > 250 && this.level_passed_timer < 260){
							alpha_set = (this.level_passed_timer-250 )/10;
						}
						if(this.level_passed_timer > 490 && this.level_passed_timer < 500){
							alpha_set = (500-this.level_passed_timer )/10;
						}
						screen.globalAlpha = alpha_set;
					}
				screen.fillStyle = "#000000";
				screen.fillRect(0,0,screenSize.x,screenSize.y);
				screen.globalAlpha = 1.0;
				
				
			}
			
		},
		// an importannt part, this is almost ENTIRELY, used for the item block
		// though I could definetely use it for spawning pipes and bullet cannons
		addBody: function(x,y,bodyType){
			if(bodyType == "Mushroom")
			{
				if(this.player.player_health < 4)
				{
					this.bodies.push(new PowerUp(x,y, "Mushroom"));

				}else{
					this.bodies.push(new PowerUp(x,y, "Fire"));
				}	
			}
			if(bodyType == "Star")
			{
				this.bodies.push(new PowerUp(x,y, "Star"));
			}
			if(bodyType == "FBall")
			{
				this.bodies.push(new Fireball(x,y,(this.player.player_dir + this.player.xSpeed)));
			}
			//console.log("Spawned Body");
			
		},
		// this is the code that deletes all the bodies then reloads them.
		bodiesReset: function()
		{
			//spice from index 0 to the length of the array deleting everything.
			this.bodies.splice(0,this.bodies.length);
			// our not-plumber
				this.player = new Player(128,500,128,256,this.audio_Control);
				
				// the ever important physic bodies array
				this.bodies = [];
				
				// load the array of not-Goombas into the bodies array
				var array_x = this.level.goombaX;
				var array_y = this.level.goombaY;
				//console.log(this.level.goombaX);
				array_length = array_x.length;
				//console.log(array_length);
				for (_i = 0;_i < array_length; _i++)
				{
					
					var x =	array_x[_i];
					var y = array_y[_i];
					//console.log(x);
					this.bodies.push(new Goomba(x,y));
				}
				
				// load the array of brick blocks into the bodies array.
				var array_x = this.level.brickX;
				var array_y = this.level.brickY;
				
				//console.log(this.level.brickX);
				array_length = array_x.length;
				//console.log(array_length);
				
				for (_i = 0;_i < array_length; _i++)
				{
					
					var x =	array_x[_i];
					var y = array_y[_i];
					//console.log(x);
					this.bodies.push(new Brick(x,y));
				}
				
				var array_x = this.level.coinX;
				var array_y = this.level.coinY;
				
				//console.log(this.level.coinX);
				array_length = array_x.length;
				//console.log(array_length);
				for (_i = 0;_i < array_length; _i++)
				{
					
					var x =	array_x[_i];
					var y = array_y[_i];
					//console.log(x);
					this.bodies.push(new Coin(x,y));
				}
				//hey look another one
				//self.bodies.push(new Goomba(900,100));
				
				
				var array_x = this.level.boxX;
				var array_y = this.level.boxY;
				var array_item = this.level.boxItem;
				//console.log(this.level.brickX);
				array_length = array_x.length;
				//console.log(array_length);
				for (_i = 0;_i < array_length; _i++)
				{
					
					var x =	array_x[_i];
					var y = array_y[_i];
					var item = array_item[_i];
					//console.log(x);
					this.bodies.push(new Block(x,y,item));
				}
				
				this.bodies.push(new PowerUp(900,100, "Star"));
				this.bodies.push(new FlagPole(this.level.flagX, this.level.flagY));
				//load the player and we're set.
				this.bodies.push(this.player);
			
			
		}
		
	}
	
	/* 
	The player Object. 
	*/
	function Player(_x,_y, _w, _h, _audio)
	{
		// the moement variables 
		this.position = new Vector2(_x,_y);
		this.xSpeed = 0;
		this.ySpeed = 0;
		
		this.level_end_flag =false;
		
		this.player_dir = 1;
		
		this.walkSpeed = 12;
		this.runSpeed = 20;
		this.player_health = 4;
		this.coins = 0;
		
		this.fire_timer = 0;
		this.block_collided = false;
		var self = this;
		this.base_tex_loaded = false;
		this.fire_tex_loaded = false;
		this.star_tex_loaded = false
		this.health_loaded = false;
		
		this.art_loaded = false;
		this.anim_loaded = false;
		this.base_texture = new Image(1024,1024);
		this.base_texture.onload = function()
		{
			self.base_tex_loaded = true;
			self.art_loaded = (self.base_tex_loaded && self.fire_tex_loaded && self.star_tex_loaded && self.health_loaded);
		}
		this.base_texture.src = 'Witch.png';
		
		
		this.fire_texture = new Image(1024,1024);
		this.fire_texture.onload = function()
		{
			self.fire_tex_loaded = true;
			self.art_loaded = (self.base_tex_loaded && self.fire_tex_loaded && self.star_tex_loaded && self.health_loaded);
		}
		this.fire_texture.src = 'WitchFire.png';
		
		this.star_texture = new Image(1024,1024);
		this.star_texture.onload = function()
		{
			self.star_tex_loaded = true;
			self.art_loaded = (self.base_tex_loaded && self.fire_tex_loaded && self.star_tex_loaded && self.health_loaded);
		}
		this.star_texture.src = 'WitchSkull.png';
		
		
		this.health_texture = new Image(512,256);
		
		//this.health_anim = false;
		this.health_texture.onload = function()
		{
			self.health_loaded = true;
			self.art_loaded = (self.base_tex_loaded && self.fire_tex_loaded && self.star_tex_loaded && self.health_loaded);
		}
		
		this.health_texture.src = 'HUDHP.png';
		
		this.anim_hud_health = new animation(true,-1,0.25,null);
		this.anim_hud_health.addFrame(0,128,128,128,0,0);
		this.anim_hud_health.addFrame(384,0,128,128,0,0);
		this.anim_hud_health.addFrame(256,0,128,128,0,0);
		this.anim_hud_health.addFrame(128,0,128,128,0,0);
		this.anim_hud_health.addFrame(0,0,128,128,0,0);
		
		this.audio_interface = _audio;
		// the jump cut is the speed that the y_speed is set to for variable jumping.
		this.jumpSpeed = -24;
		this.jumpCut = -10;
		this.jumpSpeedRun = -35;
		
		this.spawnedFireball = false;
		this.fireFlag = false;
		
		this.star_timer = 0;
		
		this.size = new Vector2(_w, _h);
		
		this.delete_self = false;
		
		// these allow the player (and all other objects using similar code to handle both 
		// tiles (just vector2s) and game blocks
		this.ground = false;
		this.blockGround = false;
		this.tileGround = false;
		
		this.runFlag = false;
		
		// our input handler almost lifted straight from 
		// Ms. Cook's code.
		this.keyboarder = new Keyboarder();
		
		// stuff connected to mercy invinciblity amongst other things.
		this.key_control = true;
		this.hurt_timer = 0;
		
		
	}
	//-----------------------------------------------------------
	Player.prototype =
	{
		//Oh fun, the work horse really.
		update: function(TileHand, gameObj)
		{
			
			if(this.base_tex_loaded == true  && this.fire_tex_loaded == true && this.star_tex_loaded == true)
			{
				if(this.anim_loaded == false){
					this.anim_pc_standR = new animation(true,-1,0.25,null);
					this.anim_pc_standR.addFrame(0,0,128,256,0,0);
					
					this.anim_pc_standL = new animation(true,-1,0.25,null);
					this.anim_pc_standL.addFrame(896,512,128,256,0,0);
					
					
					this.anim_pc_walkR = new animation(true,-1,0.18,null);
					this.anim_pc_walkR.addFrame(128,0,128,256,0,0);
					this.anim_pc_walkR.addFrame(256,0,128,256,0,0);
					this.anim_pc_walkR.addFrame(384,0,128,256,0,0);
					this.anim_pc_walkR.addFrame(512,0,128,256,0,0);
					this.anim_pc_walkR.addFrame(640,0,128,256,0,0);
					this.anim_pc_walkR.addFrame(768,0,128,256,0,0);
					
					this.anim_pc_walkL = new animation(true,-1,0.18,null);
					this.anim_pc_walkL.addFrame(128,256,128,256,0,0);
					this.anim_pc_walkL.addFrame(256,256,128,256,0,0);
					this.anim_pc_walkL.addFrame(384,256,128,256,0,0);
					this.anim_pc_walkL.addFrame(512,256,128,256,0,0);
					this.anim_pc_walkL.addFrame(640,256,128,256,0,0);
					this.anim_pc_walkL.addFrame(768,256,128,256,0,0);
					
					this.anim_pc_jumpR = new animation(true,-1,0.25,null);
					this.anim_pc_jumpR.addFrame(896,0,128,256,0,0);
					
					this.anim_pc_jumpL = new animation(true,-1,0.25,null);
					this.anim_pc_jumpL.addFrame(0,256,128,256,0,0);
					
					this.anim_pc_fireR = new animation(true,-1,0.25,null);
					this.anim_pc_fireR.addFrame(896,256,128,256,0,0);
					
					this.anim_pc_fireL = new animation(true,-1,0.25,null);
					this.anim_pc_fireL.addFrame(0,512,128,256,0,0);
					
					
					this.anim_pc_runR = new animation(true,-1,0.25,null);
					this.anim_pc_runR.addFrame(128,512,256,256,-64,0);
					this.anim_pc_runR.addFrame(384,512,256,256,-64,0);
					this.anim_pc_runR.addFrame(640,512,256,256,-64,0);
					this.anim_pc_runR.addFrame(384,512,256,256,-64,0);
					
					
					this.anim_pc_runL = new animation(true,-1,0.25,null);
					this.anim_pc_runL.addFrame(0,768,256,256,-64,0);
					this.anim_pc_runL.addFrame(256,768,256,256,-64,0);
					this.anim_pc_runL.addFrame(512,768,256,256,-64,0);
					this.anim_pc_runL.addFrame(256,768,256,256,-64,0);
					
					this.anim_pc_win = new animation(true,-1,0.25,null);
					this.anim_pc_win.addFrame(768,768,256,256,-64,0);
					
					this.animator = new animator(this.base_texture,this.anim_pc_standL);
					//console.log(this.animator);
						//console.log(this.texture);
					this.anim_loaded = true;
				}
				else
				{
					if(this.level_end_flag == true)
					{
						if(this.animator.current_animation != this.anim_pc_win)
											this.animator.changeAnim(this.anim_pc_win);  
					}
					else
					{
						if(this.ground == true){
							if(this.xSpeed == 0)
							{
								if(this.fire_timer > 15)
								{
									if(this.player_dir > 0){
										if(this.animator.current_animation != this.anim_pc_fireR)
											this.animator.changeAnim(this.anim_pc_fireR);  
									}else {
										if(this.animator.current_animation != this.anim_pc_fireL)
											this.animator.changeAnim(this.anim_pc_fireL);  
									}
								}else{
									if(this.player_dir > 0){
										if(this.animator.current_animation != this.anim_pc_standR)
											this.animator.changeAnim(this.anim_pc_standR);  
									}else {
										if(this.animator.current_animation != this.anim_pc_standL)
											this.animator.changeAnim(this.anim_pc_standL);  
									}
									
								}
								
							}else
							{
								
								if(Math.abs(this.xSpeed) < (this.runSpeed - 3))
								{
									if(this.player_dir > 0){
										if(this.animator.current_animation != this.anim_pc_walkR)
											this.animator.changeAnim(this.anim_pc_walkR);  
									}else {
										if(this.animator.current_animation != this.anim_pc_walkL)
											this.animator.changeAnim(this.anim_pc_walkL);  
									}
									
								}else{
									if(this.player_dir > 0){
										if(this.animator.current_animation != this.anim_pc_runR)
											this.animator.changeAnim(this.anim_pc_runR);  
									}else {
										if(this.animator.current_animation != this.anim_pc_runL)
											this.animator.changeAnim(this.anim_pc_runL);  
									}
								}
							}
							
						}
						else {
							if(this.player_dir > 0){
									if(this.animator.current_animation != this.anim_pc_jumpR)
										this.animator.changeAnim(this.anim_pc_jumpR);  
								}else {
									if(this.animator.current_animation != this.anim_pc_jumpL)
										this.animator.changeAnim(this.anim_pc_jumpL);  
								}
							
						}
						this.animator.update();
					}
				}
			}
			if(this.blockGround == true)
				this.blockGround = this.block_collided;
			
			// get the actually ground value from the other two.
			this.ground = (this.tileGround || this.blockGround);
			
			this.block_collided = false;
			
			// update the players position.
			this.position.x += this.xSpeed;
			this.position.y += this.ySpeed;
			
			if(this.xSpeed > 0) this.player_dir = 1;
			if(this.xSpeed < 0) this.player_dir = -1;
			
			// if there are timers running decrease them.
			if(this.hurt_timer > 0)this.hurt_timer--;
			
			if(this.star_timer > 0)this.star_timer--;
			
			if(this.fire_timer > 0)this.fire_timer--;
			
			// check and see if the player is running.
			if(this.keyboarder.isDown(this.keyboarder.KEYS.RUN))
			{
				if(this.runFlag == false && this.fireFlag == true && this.fire_timer <= 0){
					if(this.player_dir >= 0)gameObj.addBody(this.position.x+128,this.position.y+74,"FBall");
					else gameObj.addBody(this.position.x,this.position.y+74,"FBall");
					this.fire_timer = 30;
				}
				this.runFlag = true;
				
			}else 
			{
				this.runFlag = false;
			}
			
			if(this.player_health < 4 && this.fireFlag == true)this.fireFlag = false;
			
			
			
			if(this.keyboarder.isDown(this.keyboarder.KEYS.LEFT) && this.key_control == true)
			{
				if (this.runFlag == true){
					if(this.xSpeed > -this.runSpeed)
					{
						if(this.xSpeed > 0) this.xSpeed -= 1;
						else this.xSpeed -= 0.5;
						if(this.xSpeed < -this.runSpeed)this.xSpeed = -this.runSpeed;
					}
					
				}else{
					
					if(this.xSpeed < -this.walkSpeed)
					{
						if(this.xSpeed > 0) this.xSpeed -= 1;
						else this.xSpeed += 0.5;
						if(this.xSpeed > -this.walkSpeed)this.xSpeed = -this.walkSpeed;
					}else
					{
						this.xSpeed -= 0.5;
					}
					
				}
			}else if(this.keyboarder.isDown(this.keyboarder.KEYS.RIGHT) && this.key_control == true)
			{
				if (this.runFlag == true){
					if(this.xSpeed < this.runSpeed)
					{
						if(this.xSpeed < 0) this.xSpeed += 1;
						else this.xSpeed += 0.5;
						if(this.xSpeed > this.runSpeed)this.xSpeed = this.runSpeed;
					}
					
				}else{
					
					if(this.xSpeed > this.walkSpeed)
					{
						if(this.xSpeed < 0) this.xSpeed += 1;
						else this.xSpeed -= 0.5;
						if(this.xSpeed < this.walkSpeed)this.xSpeed = this.walkSpeed;
					}else
					{
						this.xSpeed += 0.5;
					}
					
				}
			}else
			{
				if(this.key_control == true){
					if(this.xSpeed > 0)
					{
						this.xSpeed -= 0.5;
						if(this.xSpeed < 0)this.xSpeed = 0;
						
					}else if(this.xSpeed < 0)
					{
						this.xSpeed += 0.5;
						if(this.xSpeed > 0)this.xSpeed = 0;
					}else this.xSpeed = 0;
				}
				
			}
			if(this.position.x < 0){
				this.position.x = 0;
				this.xSpeed = 0;
			}
			if(this.keyboarder.isDown(this.keyboarder.KEYS.SPACE) && this.ground === true)
			{
				if (this.runFlag == true && Math.abs(this.xSpeed) > 0)this.ySpeed = this.jumpSpeedRun;
				else this.ySpeed = this.jumpSpeed;
				this.ground = false;
				this.tileGround = false;
				this.blockGround = false;
				this.audio_interface.playJump();
			}
			
			if(this.ground === false && !(this.keyboarder.isDown(this.keyboarder.KEYS.SPACE)) && this.ySpeed < -8)this.ySpeed = -8
			//var _TileHandler = TileHand;
			if(this.ySpeed < 20 && this.ground == false && this.level_end_flag == false)this.ySpeed += 0.5;
			
			// the tileGround collison
			
			// if the overall ground flag is falls
			// look for tiles.
			if(this.ground=== false)
			{
				
				// good you've found a tile. move out of it, and set your flags.
				if(this.ySpeed > 0){
					while(TileHand.tileAt(this.position.x+32, this.position.y + 257))
					{
						
						if(this.ground === false){
							//this.ground = true;
							this.ySpeed = 0;
							this.key_control = true;
							this.tileGround = true;
							}
						this.position.y -= 1;
					}
					while(TileHand.tileAt(this.position.x+96, this.position.y + 257))
					{
						
						if(this.ground === false){
							//this.ground = true;
							this.ySpeed = 0;
							this.key_control = true;
							this.tileGround = true;
							}
						this.position.y -= 1;
					}
				}
				// if the ground type is tileground make sure it's still three.
			}else if(this.tileGround == true)
			{
				if(!TileHand.tileAt(this.position.x+32, this.position.y + 258) &
				!TileHand.tileAt(this.position.x+96, this.position.y + 258))
				{
					//this.ground = false;
					this.tileGround = false;
				}else 
				{
					this.tileGround = true;
					
					
				}
				
			}
			// if going up, check for tiles above.
			if(this.ySpeed < 0){
					while(TileHand.tileAt(this.position.x+32, this.position.y - 1))
					{
						this.position.y += 1;
					}
					
					while(TileHand.tileAt(this.position.x+96, this.position.y - 1))
					{
						this.position.y += 1;
					}
				}
			
			//if going right check for tiles there.
				
			if(this.xSpeed > 0){
				while(TileHand.tileAt(this.position.x+129, this.position.y+32))
				{
					this.position.x -= 1;
				}
				while(TileHand.tileAt(this.position.x+129, this.position.y+64))
				{
					this.position.x -= 1;
				}
				while(TileHand.tileAt(this.position.x+129, this.position.y+192))
				{
					this.position.x -= 1;
				}
			}
			// if going left check for tiles again.
			if(this.xSpeed < 0){
				while(TileHand.tileAt(this.position.x-1, this.position.y+32))
				{
					this.position.x += 1;
				}
				while(TileHand.tileAt(this.position.x-1, this.position.y+64))
				{
					this.position.x += 1;
				}
				while(TileHand.tileAt(this.position.x-1, this.position.y+192))
				{
					this.position.x += 1;
				}
			}
			
			
			
		},
		draw: function(screen, screenSize, cameraControl)
		{
			
			// the draw code, this will be gutted and replaced with a more comprehensive system for the characters to animate themselves.
			/* var img_mario = new Image(128,256);
			if(this.star_timer <= 0){
				if(this.fireFlag == false){
					if(this.player_dir == -1)
						img_mario.src = 'MarioTest_L.png'; // Set source path
					else
						img_mario.src = 'MarioTest_R.png'; // Set source path
				}else{
					if(this.player_dir == -1)
						img_mario.src = 'MarioFireTest_L.png'; // Set source path
					else
						img_mario.src = 'MarioFireTest_R.png'; // Set source path
				}
			} else{ 
				if(this.player_dir == -1)
						img_mario.src = 'MarioStarTest_L.png'; // Set source path
					else
						img_mario.src = 'MarioStarTest_R.png'; // Set source path
			}
			var screen_pos_x = (this.position.x - cameraControl.camera_position.x);
			var screen_pos_y = (this.position.y - cameraControl.camera_position.y);
			
			//screen.scale(this.player_dir,1);
			
			if( screen_pos_x > -300 && screen_pos_x < (screenSize.x +300) && screen_pos_y > -300 && screen_pos_y < (screenSize.y +300)){
					if((this.hurt_timer > 0 && this.hurt_timer % 16 > 8) || this.hurt_timer == 0)
					screen.drawImage(img_mario,screen_pos_x,screen_pos_y);
			} */
			//screen.scale(1,1);
			if(this.anim_loaded == true){
				
				if(this.star_timer <= 0){
					if(this.fireFlag == true){
						this.animator.texture = this.fire_texture;
					}else{
						this.animator.texture = this.base_texture;
					}
				}else
				{
					this.animator.texture = this.star_texture;
				}
				
				this.animator.draw(this.position.x,this.position.y,screen,screenSize,cameraControl);
				
			}
				
			screen.font="45px Impact";
			
			//screen.fillText("Hello World",10,30);
			//screen.fillText("Player Health: " + (100 * (this.player_health/4)) + "%",10,30);
			
			if(this.health_loaded = true)
			{
				var anim_frame = this.anim_hud_health.animation_frames[Math.floor(this.player_health)];
				
				screen.drawImage(this.health_texture,
								anim_frame.x,
								anim_frame.y,
								anim_frame.width,
								anim_frame.height,
								600,30,anim_frame.width,anim_frame.height);
								
								
				
			}
			
			var grd=screen.createLinearGradient(0,30,0,70);
			grd.addColorStop(0,"#FFFF00");
			grd.addColorStop(1,"#CCAA00");

			screen.fillStyle = grd;
			
			screen.fillText("Coins: " ,10,65);
			
			var grd2=screen.createLinearGradient(0,30,0,70);
			grd2.addColorStop(0,"#FFFFFF");
			grd2.addColorStop(1,"#AAAAAA");
			
			screen.fillStyle = grd2;
			screen.fillText(this.coins ,150,65);
		},
		checkCollision(body)
		{
			
			// more collision fun 
			// now with collision. 
			var ret_Val = false;
			
			//the for loop in the game.update function has each body check with every other, ( I know inefficent so sue me.
			//passing in the reference of the object in question.
			if(body instanceof Goomba){
				// check if it's a not-Goomba
				// if so check if the player should be hurt.
				// I borrowed this code from someone on Stack-Overflow, though I knew the basics of it
				// I was being lazy. I can't find the source now. Sorry. 
				if((body.position.x < this.position.x + this.size.x &&
					body.position.x + body.size.x > this.position.x &&
					body.position.y < this.position.y + this.size.y &&
					body.position.y + body.size.y > this.position.y ) && this.hurt_timer === 0)
				{
				/* rect1.x < rect2.x + rect2.width &&
					rect1.x + rect1.width > rect2.x &&
					rect1.y < rect2.y + rect2.height &&
					rect1.height + rect1.y > rect2.y) { */

					if(this.star_timer <= 0){
						this.ground = false;
						this.ySpeed = -10;
						this.xSpeed *= -1;
						this.key_control = false;
						this.hurt_timer = 90; 
						this.player_health--;
						ret_Val = false;
						
						this.audio_interface.playHurt();
					}else 
						ret_Val = true;
					
					
				}
				// this check whether the player is good to stomp the not-goomba
				if(body.position.x < this.position.x + this.size.x &&
					body.position.x + body.size.x > this.position.x &&
					body.position.y < this.position.y + this.size.y + 25 &&
					body.position.y + body.size.y > this.position.y + this.size.y + 0 )
				{
						
					this.ySpeed = -10;
					this.audio_interface.playCrush();
					ret_Val = true;
				}
			}
			if(body instanceof FlagPole)
			{
				if(this.position.x > body.position.x && body.passed == false)
				{
					body.passed = true;
					this.key_control = false;
					this.xSpeed = 0;
				}
				
			}
			// the power up pick up.
			if(body instanceof PowerUp){
				if((body.position.x < this.position.x + this.size.x &&
					body.position.x + body.size.x > this.position.x &&
					body.position.y < this.position.y + this.size.y &&
					body.position.y + body.size.y > this.position.y ) )
				{
				
					// do Power Up related stuff here
					ret_Val = true;
					if(body.PowerType == "Star"){
						this.star_timer = 600;
					}else{
						if(this.player_health >= 4) this.fireFlag = true;
						else this.player_health++;
					}
					this.audio_interface.playPower();
				}
			}
			// collecting coins
			if(body instanceof Coin){
				if((body.position.x < this.position.x + this.size.x &&
					body.position.x + body.size.x > this.position.x &&
					body.position.y < this.position.y + this.size.y &&
					body.position.y + body.size.y > this.position.y ) )
				{
				
					// do Power Up related stuff here
					ret_Val = true;
					this.coins++;
					this.audio_interface.playCoin();
				}
			}
			// He this code looks familiar? it's the same as the tile ground code, for both this, and the Item Box code.
			if(body instanceof Brick){
				ret_Val = false;
				if(this.ground === false){
					while( this.position.x + 32 >= body.position.x &&
						this.position.x + 32 <= body.position.x + body.size.x &&
						this.position.y + 257 >= body.position.y &&
						this.position.y + 257 <= body.position.y + body.size.x)
					{
						this.position.y--;
						
						//this.ground = true;
						this.ySpeed = 0;
						this.key_control = true;
						this.blockGround = true;
						this.block_collided = true;
					}
					while( this.position.x + 96 >= body.position.x &&
						this.position.x + 96 <= body.position.x + body.size.x &&
						this.position.y + 257 >= body.position.y &&
						this.position.y + 257 <= body.position.y + body.size.x)
					{
						this.position.y--;
						
						//this.ground = true;
						this.ySpeed = 0;
						this.key_control = true;
						this.blockGround = true;
						this.block_collided = true;
					}
					
					
				}else if(this.blockGround == true)
				{
					if(( this.position.x + 32 >= body.position.x &&
						this.position.x + 32 <= body.position.x + body.size.x &&
						this.position.y + 258 >= body.position.y &&
						this.position.y + 258 <= body.position.y + body.size.x) ||
						
						( this.position.x + 96 >= body.position.x &&
						this.position.x + 96 <= body.position.x + body.size.x &&
						this.position.y + 258 >= body.position.y &&
						this.position.y + 258 <= body.position.y + body.size.x)
						)
					{
						//this.position.y-
						//console.log("wut");
						this.block_collided = true;
					}
					
				}
				if(this.ySpeed < 0){
					while( this.position.x + 32 > body.position.x &&
							this.position.x + 32 < body.position.x + body.size.x &&
							this.position.y - 1 > body.position.y &&
							this.position.y - 1 < body.position.y + body.size.x)
						{
							this.position.y++;
							
							//this.ground = true;
							this.ySpeed = 0;
							//this.key_control = true;
							//this.blockGround = true;
							ret_Val = true;
						}
						while( this.position.x + 96 > body.position.x &&
							this.position.x + 96 < body.position.x + body.size.x &&
							this.position.y - 1 > body.position.y &&
							this.position.y - 1 < body.position.y + body.size.x)
						{
							this.position.y++;
							
							//this.ground = true;
							this.ySpeed = 0;
							//this.key_control = true;
							//this.blockGround = true;
							ret_Val = true;
						}
				}
				
				if(this.xSpeed > 0){	
					/* ( this.position.x +129> body.position.x &&
						this.position.x +129 < body.position.x + body.size.x &&
						this.position.y +32 > body.position.y &&
						this.position.y +32< body.position.y + body.size.x)
						 */
					while( this.position.x +129> body.position.x &&
							this.position.x +129 < body.position.x + body.size.x &&
							this.position.y +32 > body.position.y &&
							this.position.y +32< body.position.y + body.size.x)
					{
						this.position.x -= 1;
					}
					while( this.position.x +129> body.position.x &&
							this.position.x +129 < body.position.x + body.size.x &&
							this.position.y +64 > body.position.y &&
							this.position.y +64< body.position.y + body.size.x)
					{
						this.position.x -= 1;
					}
					while( this.position.x +129> body.position.x &&
							this.position.x +129 < body.position.x + body.size.x &&
							this.position.y +192 > body.position.y &&
							this.position.y +192< body.position.y + body.size.x)
					{
						this.position.x -= 1;
					}
				}
				if(this.xSpeed < 0){
					while( this.position.x -1> body.position.x &&
							this.position.x -1 < body.position.x + body.size.x &&
							this.position.y +32 > body.position.y &&
							this.position.y +32< body.position.y + body.size.x)
					{
						this.position.x += 1;
					}
					while( this.position.x -1> body.position.x &&
							this.position.x -1 < body.position.x + body.size.x &&
							this.position.y +64 > body.position.y &&
							this.position.y +64< body.position.y + body.size.x)
					{
						this.position.x += 1;
					}
					while( this.position.x -1> body.position.x &&
							this.position.x -1 < body.position.x + body.size.x &&
							this.position.y +192 > body.position.y &&
							this.position.y +192< body.position.y + body.size.x)
					{
						this.position.x += 1;
					}
				}
				
				
				
				//this.position.x+64, this.position.y + 257
			}
			
			// Item Box code.
			if(body instanceof Block){
				ret_Val = false;
				if(this.ground === false){
					while( this.position.x + 32 >= body.position.x &&
						this.position.x + 32 <= body.position.x + body.size.x &&
						this.position.y + 257 >= body.position.y &&
						this.position.y + 257 <= body.position.y + body.size.x)
					{
						this.position.y--;
						
						//this.ground = true;
						this.ySpeed = 0;
						this.key_control = true;
						this.blockGround = true;
						this.block_collided = true;
					}
					while( this.position.x + 96 >= body.position.x &&
						this.position.x + 96 <= body.position.x + body.size.x &&
						this.position.y + 257 >= body.position.y &&
						this.position.y + 257 <= body.position.y + body.size.x)
					{
						this.position.y--;
						
						//this.ground = true;
						this.ySpeed = 0;
						this.key_control = true;
						this.blockGround = true;
						this.block_collided = true;
					}
					
				}else if(this.blockGround == true)
				{
					if(( this.position.x + 32 >= body.position.x &&
						this.position.x + 32 <= body.position.x + body.size.x &&
						this.position.y + 258 >= body.position.y &&
						this.position.y + 258 <= body.position.y + body.size.x) ||
						
						( this.position.x + 96 >= body.position.x &&
						this.position.x + 96 <= body.position.x + body.size.x &&
						this.position.y + 258 >= body.position.y &&
						this.position.y + 258 <= body.position.y + body.size.x)
						)
					{
						//this.position.y-
						
						this.block_collided = true;
						//console.log("wut");
					}
					
				}
				if(this.ySpeed < 0){
					while( this.position.x + 32 > body.position.x &&
							this.position.x + 32 < body.position.x + body.size.x &&
							this.position.y - 1 > body.position.y &&
							this.position.y - 1 < body.position.y + body.size.x)
						{
							this.position.y++;
							
							//this.ground = true;
							this.ySpeed = 0;
							body.hit = true;
							//this.key_control = true;
							//this.blockGround = true;
							//ret_Val = true;
						}
					while( this.position.x + 96 > body.position.x &&
							this.position.x + 96 < body.position.x + body.size.x &&
							this.position.y - 1 > body.position.y &&
							this.position.y - 1 < body.position.y + body.size.x)
						{
							this.position.y++;
							
							//this.ground = true;
							this.ySpeed = 0;
							body.hit = true;
							//this.key_control = true;
							//this.blockGround = true;
							//ret_Val = true;
						}
				}
				
				if(this.xSpeed > 0){	
					/* ( this.position.x +129> body.position.x &&
						this.position.x +129 < body.position.x + body.size.x &&
						this.position.y +32 > body.position.y &&
						this.position.y +32< body.position.y + body.size.x)
						 */
					while( this.position.x +129> body.position.x &&
							this.position.x +129 < body.position.x + body.size.x &&
							this.position.y +32 > body.position.y &&
							this.position.y +32< body.position.y + body.size.x)
					{
						this.position.x -= 1;
					}
					while( this.position.x +129> body.position.x &&
							this.position.x +129 < body.position.x + body.size.x &&
							this.position.y +64 > body.position.y &&
							this.position.y +64 < body.position.y + body.size.x)
					{
						this.position.x -= 1;
					}
					
					while( this.position.x +129> body.position.x &&
							this.position.x +129 < body.position.x + body.size.x &&
							this.position.y +192 > body.position.y &&
							this.position.y +192< body.position.y + body.size.x)
					{
						this.position.x -= 1;
					}
				}
				if(this.xSpeed < 0){
					while( this.position.x -1> body.position.x &&
							this.position.x -1 < body.position.x + body.size.x &&
							this.position.y +32 > body.position.y &&
							this.position.y +32< body.position.y + body.size.x)
					{
						this.position.x += 1;
					}
					
					while( this.position.x -1> body.position.x &&
							this.position.x -1 < body.position.x + body.size.x &&
							this.position.y +64 > body.position.y &&
							this.position.y +64< body.position.y + body.size.x)
					{
						this.position.x += 1;
					}
					while( this.position.x -1> body.position.x &&
							this.position.x -1 < body.position.x + body.size.x &&
							this.position.y +192 > body.position.y &&
							this.position.y +192< body.position.y + body.size.x)
					{
						this.position.x += 1;
					}
				}
				
				
				
				//this.position.x+64, this.position.y + 257
			}
			return ret_Val;
			
		}
		
	}
	
	// the brick object's pretty simple. just sort sits there.
	// storing values.
	function Brick (_x, _y)
	{
		this.delete_self = false;
		this.position = new Vector2(_x,_y);
		this.size = new Vector2(128,128);
		this.img_brick = new Image(128,128);
		this.art_loaded = false;
		this.anim_loaded = false;
		var self = this;
		
		this.img_brick.onload = function(){
			self.art_loaded = true;
			self.anim_loaded = true;
		}
		this.img_brick.src = 'CrateBlock.png'; // Set source path
		
	}
	Brick.prototype =
	{
		draw: function(screen, screenSize, cameraControl)
		{
			if(this.art_loaded == true){
			var screen_pos_x = (this.position.x - cameraControl.camera_position.x);
			var screen_pos_y = (this.position.y - cameraControl.camera_position.y);
			if( screen_pos_x > -300 && screen_pos_x < (screenSize.x +300) && screen_pos_y > -300 && screen_pos_y < (screenSize.y +300))
					screen.drawImage(this.img_brick,screen_pos_x,screen_pos_y);
				//console.log("Wut");
			}
			
		},
		update: function(TileHand, gameObj)
		{
			// it's just a block lol
		},
		checkCollision: function(body)
		{
			// it's also just a block lol
		}
	}
	//  Coin 
	//  Coin 
	//  Coin              
	//  Coin              
	//  Coin              
	//  Coin              
	//  Coin              
	//  Coin              
	//  Coin              
	
	
	
	// same as the coin. thes don' do much.
	function Coin (_x, _y)
	{
		this.position = new Vector2(_x,_y);
		this.size = new Vector2(128,128);
		this.delete_self = false;
		
		
		this.art_loaded = false;
		this.anim_loaded = false;
		
		
		this.texture =  new Image(128,128);
		var self = this;
		this.texture.onload = function (){
			self.art_loaded = true;
			
			//console.log("Image Loaded!");
			//Goomba.art_loaded = true;
			//console.log(this);
			//console.log(self);
		};
		this.texture.onError = function ()
		{
			console.log("failed");
		};
		this.texture.src = 'BatCoin.png';
		
	}
	Coin.prototype =
	{
		draw: function(screen, screenSize, cameraControl)
		{
			if(this.art_loaded == true && this.anim_loaded == true){
				this.animator.draw(this.position.x,this.position.y,screen,screenSize,cameraControl);
				//console.log("is drawing?");
			}
			
		},
		update: function(TileHand, gameObj)
		{
			if(this.art_loaded == true){ 
			
				if(this.anim_loaded == false)
				{
					this.anim_spin = new animation(true,-1,0.25,null);
					this.anim_spin.addFrame(0,0,128,128,0,0);
					this.anim_spin.addFrame(128,0,128,128,0,0);
					this.anim_spin.addFrame(256,0,128,128,0,0);
					this.anim_spin.addFrame(384,0,128,128,0,0);
					
					
					
					this.animator = new animator(this.texture,this.anim_spin);
					//console.log(this.animator);
					//console.log(this.texture);
					this.anim_loaded = true;
				}else
				{
					this.animator.update();
					
				}
			}
			// it's just a coin lol
		},
		checkCollision: function(body)
		{
			// it's also just a coin lol
		}
	}
	
	function FlagPole (_x, _y)
	{
		this.position = new Vector2(_x,_y);
		this.size = new Vector2(128,1024);
		this.passed = false;
		this.texture = new Image(128,1024);
		this.art_loaded = false;
		
		var self = this;
		
		this.texture.onload = function(){
				self.art_loaded = true;
				console.log("worked");
		}
		this.texture.src = 'FlagPole.png';
		
		this.delete_self = false;
	}
	FlagPole.prototype =
	{
		draw: function(screen, screenSize, cameraControl)
		{
			if(this.art_loaded == true){
			var screen_pos_x = (this.position.x - cameraControl.camera_position.x-64);
			var screen_pos_y = (this.position.y - cameraControl.camera_position.y)  - 1024;
			if( screen_pos_x > -300 && screen_pos_x < (screenSize.x +300) && screen_pos_y > -1200 && screen_pos_y < (screenSize.y +1200))
					screen.drawImage(this.texture,screen_pos_x,screen_pos_y);
			}
		},
		update: function(TileHand, gameObj)
		{
			if(this.passed == true)
			{
				gameObj.level_passed = true;
				
			}
			// it's just a coin lol
		},
		checkCollision: function(body)
		{
			// it's also just a coin lol
		}
	}
	
	
	// again. this just sits there looking pretty until it's hit. 
	function Block (_x, _y, obj)
	{
		this.position = new Vector2(_x,_y);
		this.size = new Vector2(128,128);
		this.obj = obj;
		this.spawned = false;
		this.hit = false;
		this.delete_self = false;
		
		this.texture = new Image(128,128);
		this.art_loaded = false;
		this.anim_loaded = false;
		var self = this;
		
		this.texture.onload = function(){
			self.art_loaded = true;
			//self.anim_loaded = true;
		}
		this.texture.src = 'ItemCrate.png'; // Set source path
	}
	Block.prototype =
	{
		draw: function(screen, screenSize, cameraControl)
		{
			if(this.art_loaded == true && this.anim_loaded == true){
				this.animator.draw(this.position.x,this.position.y,screen,screenSize,cameraControl);
				//console.log("is drawing?");
			}
			
		},
		update: function(TileHand, gameObj)
		{
			
			
			if(this.art_loaded == true){ 
			
				if(this.anim_loaded == false)
				{
					this.anim_normal = new animation(true,-1,0.25,null);
					this.anim_normal.addFrame(0,0,128,128,0,0);
					
					this.anim_used = new animation(true,-1,0.25,null);
					this.anim_used.addFrame(128,0,128,128,0,0);
					
					
					this.animator = new animator(this.texture,this.anim_normal);
					//console.log(this.animator);
					//console.log(this.texture);
					this.anim_loaded = true;
				}else
				{
					this.animator.update();
					
				}
			}
			
			if(this.hit == true && this.spawned == false)
			{
				// do the thing!
				//console.log(gameObj);
				if(this.obj == "coin")gameObj.player.coins++;
				if(this.obj == "mushroom"){
					//console.log("spawn shroom");
					gameObj.addBody(this.position.x , this.position.y - 128, "Mushroom");
				}
				this.spawned = true;
				
			}
			if(this.hit == true && this.animator.current_animation != this.anim_used) this.animator.changeAnim(this.anim_used);
			
			
			// it's just a block lol
		},
		checkCollision: function(body)
		{
			// it's also just a block lol
		}
	}
	
	//the fireball object. should be fairly easy... should
	function Fireball(_x,_y, dir)
	{
		this.delete_self = false;
		this.delete_timer = 250;
		this.position = new Vector2(_x,_y);
		this.moveSpeed = 5;
		this.xSpeed = dir +  (this.moveSpeed * Math.sign(dir));
		//if(this.xSpeed = 0)this.xSpeed = this.moveSpeed;
		this.ySpeed = 0;
		this.size = new Vector2(32,32);
		this.ground = false;
		this.blockGround = false;
		this.tileGround = false;
		
		var self = this;
		
		this.texture = new Image(128,128);
		this.art_loaded = false;
		this.texture.onload = function()
		{
			self.art_loaded = true;
			
		}
		this.texture.src = 'FireBallTest.png'; // Set source path
		
	}
	
	Fireball.prototype = 
	{
		draw: function(screen,screenSize, cameraControl)
		{
			if(this.art_loaded == true){
				var screen_pos_x = (this.position.x - cameraControl.camera_position.x);
				var screen_pos_y = (this.position.y - cameraControl.camera_position.y);
				if( screen_pos_x > -300 && screen_pos_x < (screenSize.x +300) && screen_pos_y > -300 && screen_pos_y < (screenSize.y +300))
						screen.drawImage(this.texture,screen_pos_x,screen_pos_y);
			}
		},
		update: function(TileHand, gameObj)
		{
			
			this.delete_timer--;
			if(this.delete_timer <= 0)this.delete_self = true;
			this.ground = (this.tileGround || this.blockGround);
			this.position.x += this.xSpeed;
			this.position.y += this.ySpeed;
			
			
			//var _TileHandler = TileHand;
			if(this.ySpeed < 20 && this.ground == false)this.ySpeed += 0.5;
			
			
			if(this.ground=== false)
			{
				
			
				if(this.ySpeed > 0){
					while(TileHand.tileAt(this.position.x+16, this.position.y + 32))
					{
						
						if(this.ground === false){
							//this.ground = true;
							this.ySpeed = 0;
							//this.key_control = true;
							this.tileGround = true;
							}
						this.position.y -= 1;
					}
				}
			}else if(this.tileGround == true)
			{
				if(!TileHand.tileAt(this.position.x+16, this.position.y + 32))
				{
					//this.ground = false;
					this.tileGround = false;
				}else 
				{
					this.tileGround = true;
					
					
				}
				
			}
			
			if(this.xSpeed > 0){
				while(TileHand.tileAt(this.position.x+32, this.position.y+16))
				{
					this.position.x -= 1;
					this.xSpeed = -1 * this.moveSpeed;
				}
				
			}
			if(this.xSpeed < 0){
				while(TileHand.tileAt(this.position.x-1, this.position.y+16))
				{
					this.position.x += 1;
					this.xSpeed = this.moveSpeed;
				}
				
			}
			if(this.ground == true)
			{
				this.ground = false;
				this.tileGround = false;
				this.blockGround = false;
				this.ySpeed = -15;
				
			}
		},
		checkCollision(body)
		{
		var ret_Val = false;
			
			if(body instanceof Goomba)
			{
				ret_Val = false;
				if((body.position.x < this.position.x + this.size.x &&
					body.position.x + body.size.x > this.position.x &&
					body.position.y < this.position.y + this.size.y &&
					body.position.y + body.size.y > this.position.y ) )
				{
					ret_Val = true;
					this.delete_self = true;
				}
			}
			// Once again, Simpler but similar to how the PC does it.
			if(body instanceof Brick){
				ret_Val = false;
				if(this.ground === false){
					while( this.position.x + 16 > body.position.x &&
						this.position.x + 16 < body.position.x + body.size.x &&
						this.position.y + 32 > body.position.y &&
						this.position.y + 32 < body.position.y + body.size.x)
					{
						this.position.y--;
						
						//this.ground = true;
						this.ySpeed = 0;
						this.key_control = true;
						this.blockGround = true;
					}
					
					
				}else if(this.blockGround == true)
				{
					if(!( this.position.x + 16 > body.position.x &&
						this.position.x + 16 < body.position.x + body.size.x &&
						this.position.y + 32 > body.position.y &&
						this.position.y + 32 < body.position.y + body.size.x))
					{
						//this.position.y--;
						this.blockGround = false;
							
					}else
					{
						this.blockGround = true;
					}
					
				}
				if(this.ySpeed < 0){
					while( this.position.x + 16 > body.position.x &&
							this.position.x + 16 < body.position.x + body.size.x &&
							this.position.y - 1 > body.position.y &&
							this.position.y - 1 < body.position.y + body.size.x)
						{
							this.position.y++;
							//console.log("is it this one?");
							//this.ground = true;
							this.ySpeed = 0;
							//this.key_control = true;
							//this.blockGround = true;
							//ret_Val = true;
						}
				}
				
				
				if(this.xSpeed > 0){	
					/* ( this.position.x +129> body.position.x &&
						this.position.x +129 < body.position.x + body.size.x &&
						this.position.y +32 > body.position.y &&
						this.position.y +32< body.position.y + body.size.x)
						 */
					while( this.position.x +32> body.position.x &&
							this.position.x +32 < body.position.x + body.size.x &&
							this.position.y +16 > body.position.y &&
							this.position.y +16< body.position.y + body.size.x)
					{
						this.position.x -= 1;
						this.xSpeed = -(this.moveSpeed);
					}
				}
				if(this.xSpeed < 0){
					while( this.position.x -1> body.position.x &&
							this.position.x -1 < body.position.x + body.size.x &&
							this.position.y +16 > body.position.y &&
							this.position.y +16< body.position.y + body.size.x)
					{
						this.position.x += 1;
						this.xSpeed = (this.moveSpeed);
					}
				}
				
				
				
				//this.position.x+64, this.position.y + 257
			}
			if(body instanceof Block){
				ret_Val = false;
				if(this.ground === false){
					while( this.position.x + 16 > body.position.x &&
						this.position.x + 16 < body.position.x + body.size.x &&
						this.position.y + 32 > body.position.y &&
						this.position.y + 32 < body.position.y + body.size.x)
					{
						this.position.y--;
						
						//this.ground = true;
						this.ySpeed = 0;
						this.key_control = true;
						this.blockGround = true;
					}
					
					
				}else if(this.blockGround == true)
				{
					if(!( this.position.x + 16 > body.position.x &&
						this.position.x + 16 < body.position.x + body.size.x &&
						this.position.y + 32 > body.position.y &&
						this.position.y + 32 < body.position.y + body.size.x))
					{
						//this.position.y--;
						this.blockGround = false;
							
					}else
					{
						this.blockGround = true;
					}
					
				}
				if(this.ySpeed < 0){
					while( this.position.x + 16 > body.position.x &&
							this.position.x + 16 < body.position.x + body.size.x &&
							this.position.y - 1 > body.position.y &&
							this.position.y - 1 < body.position.y + body.size.x)
						{
							this.position.y++;
							//console.log("is it this one?");
							//this.ground = true;
							this.ySpeed = 0;
							//this.key_control = true;
							//this.blockGround = true;
							//ret_Val = true;
						}
				}
				
				
				if(this.xSpeed > 0){	
					/* ( this.position.x +129> body.position.x &&
						this.position.x +129 < body.position.x + body.size.x &&
						this.position.y +32 > body.position.y &&
						this.position.y +32< body.position.y + body.size.x)
						 */
					while( this.position.x +32> body.position.x &&
							this.position.x +32 < body.position.x + body.size.x &&
							this.position.y +16 > body.position.y &&
							this.position.y +16< body.position.y + body.size.x)
					{
						this.position.x -= 1;
						this.xSpeed = -(this.moveSpeed);
					}
				}
				if(this.xSpeed < 0){
					while( this.position.x -1> body.position.x &&
							this.position.x -1 < body.position.x + body.size.x &&
							this.position.y +16 > body.position.y &&
							this.position.y +16< body.position.y + body.size.x)
					{
						this.position.x += 1;
						this.xSpeed = (this.moveSpeed);
					}
				}
				
				
				
				//this.position.x+64, this.position.y + 257
			}
			return ret_Val;	
		}
		
	};
	
	// the power up object which is dirived from the not-Goomba of all things.
	// since the main power up the mushroom slides around and interacts with objects it works pretty well.
	function PowerUp(_x,_y,Power)
	{
		this.delete_self = false;
		this.position = new Vector2(_x,_y);
		this.moveSpeed = 4;
		this.PowerType = Power;
		if(this.PowerType == "Fire")this.moveSpeed = 0;
		
		this.xSpeed = this.moveSpeed;
		this.ySpeed = 0;
		
		this.size = new Vector2(128,128);
		
		this.ground = false;
		this.blockGround = false;
		this.tileGround = false;
		
		
		this.art_loaded = false;
		this.anim_loaded = false;
		
		
		this.texture =  new Image(102,256);
		var self = this;
		this.texture.onload = function (){
			self.art_loaded = true;
			
			//console.log("Image Loaded!");
			//Goomba.art_loaded = true;
			//console.log(this);
			//console.log(self);
		};
		this.texture.onError = function ()
		{
			console.log("failed");
		};
		this.texture.src = 'Powerups.png';
		
	}
	
	
	
	
	
	
	PowerUp.prototype = 
	{
		//would you look at that. It's basically the same code used to load in and draw an image.
		draw: function(screen, screenSize, cameraControl)
		{
			if(this.art_loaded == true && this.anim_loaded == true){
				this.animator.draw(this.position.x,this.position.y,screen,screenSize,cameraControl);
				//console.log("is drawing?");
			}
			
		},
		
		// While it's a power up and doesn't have near as crazy amounts of collision checks as the player character
		// you should begin to see a pattern here. it basically runs off the same concepts as the players update function.
		// tile checks..
		update: function(TileHand, gameObj)
		{
			
			if(this.art_loaded == true){ 
			
				if(this.anim_loaded == false)
				{
					this.anim_pumpkin = new animation(true,-1,0.25,null);
					this.anim_pumpkin.addFrame(0,0,128,128,0,0);
					this.anim_pumpkin.addFrame(128,0,128,128,0,0);
					this.anim_pumpkin.addFrame(256,0,128,128,0,0);
					this.anim_pumpkin.addFrame(384,0,128,128,0,0);
					this.anim_pumpkin.addFrame(512,0,128,128,0,0);
					this.anim_pumpkin.addFrame(640,0,128,128,0,0);
					
					this.anim_fire = new animation(true,-1,0.25,null);
					this.anim_fire.addFrame(768,0,128,128,0,0);
					this.anim_fire.addFrame(896,0,128,128,0,0);
					this.anim_fire.addFrame(0,128,128,128,0,0);
					
					this.anim_skull = new animation(true,-1,0.25,null);
					this.anim_skull.addFrame(128,128,128,128,0,0);
					this.anim_skull.addFrame(256,128,128,128,0,0);
					this.anim_skull.addFrame(384,128,128,128,0,0);
					this.anim_skull.addFrame(512,128,128,128,0,0);
					if(this.PowerType == "Mushroom")this.animator = new animator(this.texture,this.anim_pumpkin);
					if(this.PowerType == "Fire")this.animator = new animator(this.texture,this.anim_fire);
					if(this.PowerType == "Star")this.animator = new animator(this.texture,this.anim_skull);
					//console.log(this.animator);
					//console.log(this.texture);
					this.anim_loaded = true;
				}else
				{
					this.animator.update();
					
				}
			}
			
			this.ground = (this.tileGround || this.blockGround);
			this.position.x += this.xSpeed;
			this.position.y += this.ySpeed;
			
			
			//var _TileHandler = TileHand;
			if(this.ySpeed < 20 && this.ground == false)this.ySpeed += 0.5;
			
			
			if(this.ground=== false)
			{
				
			
				if(this.ySpeed > 0){
					while(TileHand.tileAt(this.position.x+64, this.position.y + 128))
					{
						
						if(this.ground === false){
							//this.ground = true;
							this.ySpeed = 0;
							//this.key_control = true;
							this.tileGround = true;
							}
						this.position.y -= 1;
					}
				}
			}else if(this.tileGround == true)
			{
				if(!TileHand.tileAt(this.position.x+64, this.position.y + 129))
				{
					//this.ground = false;
					this.tileGround = false;
				}else 
				{
					this.tileGround = true;
					
					
				}
				
			}
			
			if(this.xSpeed > 0){
				while(TileHand.tileAt(this.position.x+129, this.position.y+32))
				{
					this.position.x -= 1;
					this.xSpeed = -1 * this.moveSpeed;
				}
				
			}
			if(this.xSpeed < 0){
				while(TileHand.tileAt(this.position.x-1, this.position.y+32))
				{
					this.position.x += 1;
					this.xSpeed = this.moveSpeed;
				}
				
			}
			if(this.ground == true && this.PowerType == "Star")
			{
				this.ground = false;
				this.tileGround = false;
				this.blockGround = false;
				this.ySpeed = -15;
				
			}
		},
		checkCollision(body)
		{
		var ret_Val = false;
			
			// Once again, Simpler but similar to how the PC does it.
			if(body instanceof Brick){
				ret_Val = false;
				if(this.ground === false){
					while( this.position.x + 64 > body.position.x &&
						this.position.x + 64 < body.position.x + body.size.x &&
						this.position.y + 128 > body.position.y &&
						this.position.y + 128 < body.position.y + body.size.x)
					{
						this.position.y--;
						
						//this.ground = true;
						this.ySpeed = 0;
						this.key_control = true;
						this.blockGround = true;
					}
					
					
				}else if(this.blockGround == true)
				{
					if(!( this.position.x + 64 > body.position.x &&
						this.position.x + 64 < body.position.x + body.size.x &&
						this.position.y + 128 > body.position.y &&
						this.position.y + 128 < body.position.y + body.size.x))
					{
						//this.position.y--;
						this.blockGround = false;
							
					}else
					{
						this.blockGround = true;
					}
					
				}
				if(this.ySpeed < 0){
					while( this.position.x + 64 > body.position.x &&
							this.position.x + 64 < body.position.x + body.size.x &&
							this.position.y - 1 > body.position.y &&
							this.position.y - 1 < body.position.y + body.size.x)
						{
							this.position.y++;
							//console.log("is it this one?");
							//this.ground = true;
							this.ySpeed = 0;
							//this.key_control = true;
							//this.blockGround = true;
							//ret_Val = true;
						}
				}
				
				
				if(this.xSpeed > 0){	
					/* ( this.position.x +129> body.position.x &&
						this.position.x +129 < body.position.x + body.size.x &&
						this.position.y +32 > body.position.y &&
						this.position.y +32< body.position.y + body.size.x)
						 */
					while( this.position.x +129> body.position.x &&
							this.position.x +129 < body.position.x + body.size.x &&
							this.position.y +32 > body.position.y &&
							this.position.y +32< body.position.y + body.size.x)
					{
						this.position.x -= 1;
						this.xSpeed = -(this.moveSpeed);
					}
				}
				if(this.xSpeed < 0){
					while( this.position.x -1> body.position.x &&
							this.position.x -1 < body.position.x + body.size.x &&
							this.position.y +32 > body.position.y &&
							this.position.y +32< body.position.y + body.size.x)
					{
						this.position.x += 1;
						this.xSpeed = (this.moveSpeed);
					}
				}
				
				
				
				//this.position.x+64, this.position.y + 257
			}
			if(body instanceof Block){
				ret_Val = false;
				if(this.ground === false){
					while( this.position.x + 64 > body.position.x &&
						this.position.x + 64 < body.position.x + body.size.x &&
						this.position.y + 128 > body.position.y &&
						this.position.y + 128 < body.position.y + body.size.x)
					{
						this.position.y--;
						
						//this.ground = true;
						this.ySpeed = 0;
						this.key_control = true;
						this.blockGround = true;
					}
					
					
				}else if(this.blockGround == true)
				{
					if(!( this.position.x + 64 > body.position.x &&
						this.position.x + 64 < body.position.x + body.size.x &&
						this.position.y + 128 > body.position.y &&
						this.position.y + 128 < body.position.y + body.size.x))
					{
						//this.position.y--;
						this.blockGround = false;
							
					}else
					{
						this.blockGround = true;
					}
					
				}
				if(this.ySpeed < 0){
					while( this.position.x + 64 > body.position.x &&
							this.position.x + 64 < body.position.x + body.size.x &&
							this.position.y - 1 > body.position.y &&
							this.position.y - 1 < body.position.y + body.size.x)
						{
							this.position.y++;
							//console.log("is it this one?");
							//this.ground = true;
							this.ySpeed = 0;
							//this.key_control = true;
							//this.blockGround = true;
							//ret_Val = true;
						}
				}
				
				
				if(this.xSpeed > 0){	
					/* ( this.position.x +129> body.position.x &&
						this.position.x +129 < body.position.x + body.size.x &&
						this.position.y +32 > body.position.y &&
						this.position.y +32< body.position.y + body.size.x)
						 */
					while( this.position.x +129> body.position.x &&
							this.position.x +129 < body.position.x + body.size.x &&
							this.position.y +32 > body.position.y &&
							this.position.y +32< body.position.y + body.size.x)
					{
						this.position.x -= 1;
						this.xSpeed = -(this.moveSpeed);
					}
				}
				if(this.xSpeed < 0){
					while( this.position.x -1> body.position.x &&
							this.position.x -1 < body.position.x + body.size.x &&
							this.position.y +32 > body.position.y &&
							this.position.y +32< body.position.y + body.size.x)
					{
						this.position.x += 1;
						this.xSpeed = (this.moveSpeed);
					}
				}
				
				
				
				//this.position.x+64, this.position.y + 257
			}
			return ret_Val;	
		}
	}
	
	
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

	
	// the not-goomba... which is called Goomba.... whoops, lol. pretty obvious on that one.
	// still if you look at the way the power up is set up, it's basically the same.
	function Goomba(_x,_y)
	{
		this.delete_self = false;
		this.position = new Vector2(_x,_y);
		this.moveSpeed = 3;
		this.xSpeed = this.moveSpeed;
		this.ySpeed = 0;
		
		
		this.size = new Vector2(128,128);
		
		this.ground = false;
		this.blockGround = false;
		this.tileGround = false;
		
		//console.log("Goomba?");
		
		this.art_loaded = false;
		this.anim_loaded = false;
		
		
		this.texture =  new Image(128,128);
		var self = this;
		this.texture.onload = function (){
			self.art_loaded = true;
			
			//console.log("Image Loaded!");
			//Goomba.art_loaded = true;
			//console.log(this);
			//console.log(self);
		};
		this.texture.onError = function ()
		{
			console.log("failed");
		};
		this.texture.src = 'SpiderSprites.png';
		
		
		
		
	}

	Goomba.prototype = 
	{
		// I got this running and copied it into almost every other object in the game.
		draw: function(screen, screenSize, cameraControl)
		{
			
			//console.log(this.art_loaded );
		/* 	var img_goomb = new Image(128,128);
			img_goomb.src = 'GoombaTest.png'; // Set source path
			var screen_pos_x = (this.position.x - cameraControl.camera_position.x);
			var screen_pos_y = (this.position.y - cameraControl.camera_position.y);
			if( screen_pos_x > -300 && screen_pos_x < (screenSize.x +300) && screen_pos_y > -300 && screen_pos_y < (screenSize.y +300))
					screen.drawImage(img_goomb,screen_pos_x,screen_pos_y);
				 */
			if(this.art_loaded == true && this.anim_loaded == true){
				this.animator.draw(this.position.x,this.position.y,screen,screenSize,cameraControl);
				//console.log("is drawing?");
			}
		},
		
		// It's the same old story, same old song and dance.
		// my friend!
		update: function(TileHand, gameObj)
		{
			if(this.art_loaded == true){ 
			
				if(this.anim_loaded == false)
				{
					this.anim_walk_left = new animation(true,-1,0.25,null);
					this.anim_walk_left.addFrame(0,0,128,128,0,0);
					this.anim_walk_left.addFrame(128,0,128,128,0,0);
					this.anim_walk_left.addFrame(256,0,128,128,0,0);
					this.anim_walk_left.addFrame(384,0,128,128,0,0);
					
					this.anim_walk_right = new animation(true,-1,0.25,null);
					this.anim_walk_right.addFrame(0,128,128,128,0,0);
					this.anim_walk_right.addFrame(128,128,128,128,0,0);
					this.anim_walk_right.addFrame(256,128,128,128,0,0);
					this.anim_walk_right.addFrame(384,128,128,128,0,0);
					
					this.anim_turn_l_to_r = new animation(false,0,0.25,this.anim_walk_right);
					this.anim_turn_l_to_r.addFrame(512,0,128,128,0,0);
					this.anim_turn_l_to_r.addFrame(640,0,128,128,0,0);
					this.anim_turn_l_to_r.addFrame(768,0,128,128,0,0);
					this.anim_turn_l_to_r.addFrame(896,0,128,128,0,0);
					
					this.anim_turn_r_to_l = new animation(false,0,0.25,this.anim_walk_left);
					this.anim_turn_r_to_l.addFrame(512,128,128,128,0,0);
					this.anim_turn_r_to_l.addFrame(640,128,128,128,0,0);
					this.anim_turn_r_to_l.addFrame(768,128,128,128,0,0);
					this.anim_turn_r_to_l.addFrame(896,128,128,128,0,0);
					
					this.animator = new animator(this.texture,this.anim_walk_right);
					//console.log(this.animator);
					//console.log(this.texture);
					this.anim_loaded = true;
				}else
				{
					if(this.xSpeed > 0 && (this.animator.current_animation != this.anim_turn_l_to_r && this.animator.current_animation != this.anim_walk_right)) this.animator.changeAnim(this.anim_turn_l_to_r);
					if(this.xSpeed < 0 && (this.animator.current_animation != this.anim_turn_r_to_l && this.animator.current_animation != this.anim_walk_left)) this.animator.changeAnim(this.anim_turn_r_to_l);
					
					this.animator.update();
					
				}
			}
			this.ground = (this.tileGround || this.blockGround);
			this.position.x += this.xSpeed;
			this.position.y += this.ySpeed;
			//var _TileHandler = TileHand;
			if(this.ySpeed < 20 && this.ground == false)this.ySpeed += 0.5;
			
			
			
			if(this.ground=== false)
			{
				
			
				if(this.ySpeed > 0){
					while(TileHand.tileAt(this.position.x+64, this.position.y + 128))
					{
						
						if(this.ground === false){
							//this.ground = true;
							this.ySpeed = 0;
							//this.key_control = true;
							this.tileGround = true;
							}
						this.position.y -= 1;
					}
				}
			}else if(this.tileGround == true)
			{
				if(!TileHand.tileAt(this.position.x+64, this.position.y + 129))
				{
					//this.ground = false;
					this.tileGround = false;
				}else 
				{
					this.tileGround = true;
					
					
				}
				
			}
			
			if(this.xSpeed > 0){
				while(TileHand.tileAt(this.position.x+129, this.position.y+32))
				{
					this.position.x -= 1;
					this.xSpeed = -1 * this.moveSpeed;
				}
				
			}
			if(this.xSpeed < 0){
				while(TileHand.tileAt(this.position.x-1, this.position.y+32))
				{
					this.position.x += 1;
					this.xSpeed = this.moveSpeed;
				}
				
			}
		},
		checkCollision(body)
		{
		var ret_Val = false;
		// this is the only place it differs
		// when two Goombas meet they bounce off of one another. 
		// as they doo in mario.
			if(body instanceof Goomba){
				
				if(body.position.x  < this.position.x + this.size.x + 64 &&
					body.position.x + body.size.x > this.position.x + 64 &&
					body.position.y < this.position.y + this.size.y &&
					body.position.y + body.size.y > this.position.y )
				{
						
					//console.log("Goomba Collision Right");
					this.xSpeed = -1 * this.moveSpeed;
					ret_Val = false;
				}
				if(body.position.x  < this.position.x + this.size.x - 64 &&
					body.position.x + body.size.x > this.position.x - 64 &&
					body.position.y < this.position.y + this.size.y &&
					body.position.y + body.size.y > this.position.y )
				{
						
					//console.log("Goomba Collision Left");
					this.xSpeed = this.moveSpeed;
					ret_Val = false;
				}
				
			}
			
			// it's the same old story- *brick*
			if(body instanceof Brick){
				ret_Val = false;
				if(this.ground === false){
					while( this.position.x + 64 > body.position.x &&
						this.position.x + 64 < body.position.x + body.size.x &&
						this.position.y + 128 > body.position.y &&
						this.position.y + 128 < body.position.y + body.size.x)
					{
						this.position.y--;
						
						//this.ground = true;
						this.ySpeed = 0;
						this.key_control = true;
						this.blockGround = true;
					}
					
					
				}else if(this.blockGround == true)
				{
					if(!( this.position.x + 64 > body.position.x &&
						this.position.x + 64 < body.position.x + body.size.x &&
						this.position.y + 128 > body.position.y &&
						this.position.y + 128 < body.position.y + body.size.x))
					{
						//this.position.y--;
						this.blockGround = false;
							
					}else
					{
						this.blockGround = true;
					}
					
				}
				if(this.ySpeed < 0){
					while( this.position.x + 64 > body.position.x &&
							this.position.x + 64 < body.position.x + body.size.x &&
							this.position.y - 32 > body.position.y &&
							this.position.y - 32 < body.position.y + body.size.x)
						{
							this.position.y++;
							
							//this.ground = true;
							this.ySpeed = 0;
							//this.key_control = true;
							//this.blockGround = true;
							//ret_Val = true;
						}
				}
				
				if(this.xSpeed > 0){	
					/* ( this.position.x +129> body.position.x &&
						this.position.x +129 < body.position.x + body.size.x &&
						this.position.y +32 > body.position.y &&
						this.position.y +32< body.position.y + body.size.x)
						 */
					while( this.position.x +129> body.position.x &&
							this.position.x +129 < body.position.x + body.size.x &&
							this.position.y +32 > body.position.y &&
							this.position.y +32< body.position.y + body.size.x)
					{
						this.position.x -= 1;
						this.xSpeed = -this.moveSpeed;
					}
				}
				if(this.xSpeed < 0){
					while( this.position.x -1> body.position.x &&
							this.position.x -1 < body.position.x + body.size.x &&
							this.position.y +32 > body.position.y &&
							this.position.y +32< body.position.y + body.size.x)
					{
						this.position.x += 1;
						this.xSpeed = this.moveSpeed;
					}
				}
				
				
				
				//this.position.x+64, this.position.y + 257
			}
			if(body instanceof Block){
				ret_Val = false;
				if(this.ground === false){
					while( this.position.x + 64 > body.position.x &&
						this.position.x + 64 < body.position.x + body.size.x &&
						this.position.y + 128 > body.position.y &&
						this.position.y + 128 < body.position.y + body.size.x)
					{
						this.position.y--;
						
						//this.ground = true;
						this.ySpeed = 0;
						this.key_control = true;
						this.blockGround = true;
					}
					
					
				}else if(this.blockGround == true)
				{
					if(!( this.position.x + 64 > body.position.x &&
						this.position.x + 64 < body.position.x + body.size.x &&
						this.position.y + 128 > body.position.y &&
						this.position.y + 128 < body.position.y + body.size.x))
					{
						//this.position.y--;
						this.blockGround = false;
							
					}else
					{
						this.blockGround = true;
					}
					
				}
				if(this.ySpeed < 0){
					while( this.position.x + 64 > body.position.x &&
							this.position.x + 64 < body.position.x + body.size.x &&
							this.position.y - 32 > body.position.y &&
							this.position.y - 32 < body.position.y + body.size.x)
						{
							this.position.y++;
							
							//this.ground = true;
							this.ySpeed = 0;
							//this.key_control = true;
							//this.blockGround = true;
							//ret_Val = true;
						}
				}
				
				if(this.xSpeed > 0){	
					/* ( this.position.x +129> body.position.x &&
						this.position.x +129 < body.position.x + body.size.x &&
						this.position.y +32 > body.position.y &&
						this.position.y +32< body.position.y + body.size.x)
						 */
					while( this.position.x +129> body.position.x &&
							this.position.x +129 < body.position.x + body.size.x &&
							this.position.y +32 > body.position.y &&
							this.position.y +32< body.position.y + body.size.x)
					{
						this.position.x -= 1;
						this.xSpeed = -this.moveSpeed;
					}
				}
				if(this.xSpeed < 0){
					while( this.position.x -1> body.position.x &&
							this.position.x -1 < body.position.x + body.size.x &&
							this.position.y +32 > body.position.y &&
							this.position.y +32< body.position.y + body.size.x)
					{
						this.position.x += 1;
						this.xSpeed = this.moveSpeed;
					}
				}
				
				
				
				//this.position.x+64, this.position.y + 257
			}
			return ret_Val;	
		}
	}
	
	// very simply an object meant for storing and drawing tiles 
	// and replying to poles on their position.
	function TileHandler()
	{
		this.collision_tiles = new Array();
		this.vis_tile = new Array();
		
		var self = this;
		this.isLoaded = false;
		this.img_tile = new Image(384,384);
		this.img_tile.onload = function()
		{
			self.isLoaded = true;
			
		}
		this.img_tile.src = 'GroundTiles.png'; // Set source path
		
		
			
	}
	
	TileHandler.prototype = 
	{
		makeTiles: function(level_data)
		{
			var array_x = level_data.tileX;
			var array_y = level_data.tileY;
			//console.log(level_data.tileX);
			array_length = array_x.length;
			
			for (_i = 0;_i < array_length; _i++)
			{
				
				var x =	array_x[_i];
				var y = array_y[_i];
				//console.log(x);
				this.collision_tiles.push(new Vector2(x,y));
			}
			
			
			for(var j = 0; j < this.collision_tiles.length; j++)
			{
				var current_vis_index = 4;
				if(!this.tileAt(this.collision_tiles[j].x-64,this.collision_tiles[j].y+ 64 ))current_vis_index = 3;
				if(!this.tileAt(this.collision_tiles[j].x+196, this.collision_tiles[j].y+ 64))current_vis_index = 5;
				
				
				if(current_vis_index == 3)
				{
					if(!this.tileAt(this.collision_tiles[j].x+ 64,this.collision_tiles[j].y - 128 ))current_vis_index = 0;
					if(!this.tileAt(this.collision_tiles[j].x+ 64,this.collision_tiles[j].y + 129 ))current_vis_index = 6;
				}
				if(current_vis_index == 4)
				{
					if(!this.tileAt(this.collision_tiles[j].x+ 64,this.collision_tiles[j].y - 128 ))current_vis_index = 1;
					if(!this.tileAt(this.collision_tiles[j].x+ 64,this.collision_tiles[j].y + 129 ))current_vis_index = 7;
				}
				if(current_vis_index == 5)
				{
					if(!this.tileAt(this.collision_tiles[j].x+ 64,this.collision_tiles[j].y - 128 ))current_vis_index = 2;
					if(!this.tileAt(this.collision_tiles[j].x+ 64,this.collision_tiles[j].y + 129 ))current_vis_index = 8;
				}
				this.vis_tile.push(current_vis_index);
				
			}
			/* for(var i = 0; i < 79;i++)
			{
				
				var x = (i *128);
				for(var j = 0; j < 4; j++)
				{
					
				var y = (j* 128) + 2560;
				this.collision_tiles.push(new Vector2(x,y));
				}
				
			} */
			
		},
		// would you look at that... it's almost the exact same.
		draw: function(screen,screenSize,gameSize, camera)
		{
		
			for(var i = 0; i < this.collision_tiles.length; i++){
			var obj = this.collision_tiles[i];
			
				var screen_pos_x = (obj.x - camera.camera_position.x);
				var screen_pos_y = (obj.y - camera.camera_position.y);
				if( screen_pos_x > -300 && screen_pos_x < (screenSize.x +300) && screen_pos_y > -300 && screen_pos_y < (screenSize.y +300))
					
					var image_x_pos = this.vis_tile[i];
					image_x_pos = (image_x_pos % 3) * 128;
					var image_y_pos = this.vis_tile[i];
					image_y_pos = Math.floor(image_y_pos / 3);
					image_y_pos *= 128;
					screen.drawImage(this.img_tile,image_x_pos,image_y_pos,128,128,screen_pos_x,screen_pos_y,128,128);
			}
			
			
		},
		//check whether the point specified is within any of the tiles.
		tileAt: function(_x,_y){
			var returnVal = false
			for(const obj of this.collision_tiles){
				if( _x >= obj.x && _x <= obj.x+128 && _y >= obj.y && _y <= obj.y+128)
					returnVal = true;
				
			}
			return returnVal;
			
		}
		
	}
	
	// wooo this monster right here.
	// this thing is responsible for handingly camera positioning.
	// it's both a blessing... and a curse.
	function Camera_Controller(screen,screenSize,gameSize)
	{
		this.screen = screen;
		this.screenSize = screenSize;
		this.gameSize = gameSize;
		this.camera_position =  new Vector2(0,2000);
		this.camera_seek = new Vector2(0,2000);
		this.camera_previous = new Vector2(0,0);
		
		this.jump_down_trigger = false;
		
		this.grid_offset = new Vector2(0,0);
		this.bg1Loaded = false;
		this.bg2Loaded = false;
		this.bg3Loaded = false;
		var self = this;
		
		this.camera_reset_flag = false;
		
		
		this.bg_layer_1 = new Image(1024, 512);
		
		this.bg_layer_1.onload = function(){
			self.bg1Loaded = true;
		}
		this.bg_layer_1.src = "BGLayer1.png";
		
		this.bg_layer_2_offset = 0;
		this.bg_layer_2 = new Image(512, 256);
		
		this.bg_layer_2.onload = function(){
			self.bg2Loaded = true;
		}
		this.bg_layer_2.src = "BGLayer2.png";
		
		this.bg_layer_3_offset = 0;
		this.bg_layer_3 = new Image(512, 256);
		
		this.bg_layer_3.onload = function(){
			self.bg3Loaded = true;
		}
		this.bg_layer_3.src = "BGLayer3.png";
		
	};
	
	
	Camera_Controller.prototype = {
		update: function(_player){
			// allows the camera controller to simply add this to the Player's position to get the game's offset.
			var centerOffset = new Vector2(-683,-384);
			// sort of, it would be a bit off is we didn't find the players center first.
			var halfSize = new Vector2(_player.size.x /2, _player.size.y /2);
			
			// Code for running the camera, I need to gut this and revamp it soon, but not tonight.

				var play_center = _player.position.add(halfSize);
				//this.jump_down_trigger = false;
				
				
				this.camera_seek = play_center.add(centerOffset);
			
			this.camera_seek.y += 40;
			
			// the code to cause the camera to seek it's new position.. needs to be retooled.
			// add easing into position to make less jaring. 
			if(this.camera_seek.x > this.camera_position.x)
			{
				this.camera_position.x += Math.min((this.camera_seek.x - this.camera_position.x),32);
			}
			if(this.camera_seek.y > this.camera_position.y)
			{
				this.camera_position.y += Math.min((this.camera_seek.y - this.camera_position.y),32);
			}
			
			if(this.camera_seek.x < this.camera_position.x)
			{
				this.camera_position.x -= Math.min(Math.abs(this.camera_seek.x - this.camera_position.x),32);
			}
			if(this.camera_seek.y < this.camera_position.y)
			{
				this.camera_position.y -= Math.min(Math.abs(this.camera_seek.y - this.camera_position.y),32);
			}
			// stops the camera, at the borders.
			if(this.camera_position.x < 0)this.camera_position.x = 0;
			if(this.camera_position.y < 0)this.camera_position.y = 0;
			if((this.camera_position.x + this.screenSize.x) > this.gameSize.x)this.camera_position.x = (this.gameSize.x - this.screenSize.x);
			if((this.camera_position.y + this.screenSize.y) > this.gameSize.y)this.camera_position.y = (this.gameSize.y - this.screenSize.y);

			// if The game needs to move quickly I set a flag to have it teleport to it's new position.
			if(this.camera_reset_flag == true){
				this.camera_position.x = this.camera_seek.x;
				this.camera_position.y = this.camera_seek.y;
				this.camera_reset_flag = false;
			}
			
			
			
			
		// Background art stuff.
			var camera_offset = this.camera_position.subtract( this.camera_previous);
			this.camera_previous = this.camera_position.copyVector();
			this.grid_offset = this.grid_offset.subtract(camera_offset);
			
			this.bg_layer_2_offset = this.bg_layer_2_offset - Math.floor(camera_offset.x/4);
			if(this.bg_layer_2_offset > 512) this.bg_layer_2_offset-=512;
			if(this.bg_layer_2_offset < -512) this.bg_layer_2_offset+=512;
			
			this.bg_layer_3_offset = this.bg_layer_3_offset - Math.floor(camera_offset.x/2);
			if(this.bg_layer_3_offset > 512) this.bg_layer_3_offset-=512;
			if(this.bg_layer_3_offset < -512) this.bg_layer_3_offset+=512;
			
			
			if(this.grid_offset.x > 256)this.grid_offset.x -= 256;
			if(this.grid_offset.x < -256)this.grid_offset.x += 256;
			if(this.grid_offset.y > 256)this.grid_offset.y -= 256;
			if(this.grid_offset.y < -256)this.grid_offset.y += 256;
			
		},
		
		draw: function(){
			// it's the actual code that draws the bg grid.
			var img_grid = new Image(256,256);
			img_grid.src = 'BGTestGrid.png'; // Set source path
			for(var j = -1; (j * 256) < (this.screenSize.y + 256); j++){
				
			new_grid = new Vector2(-256,j*256);
			new_grid = new_grid.add(this.grid_offset);
			//new_grid = new_grid.add(grid_pos);
				
				for(var i = -1; (i * 256) < (this.screenSize.x + 256); i++){
					this.screen.drawImage(img_grid,new_grid.x,new_grid.y);
					new_pos2 = new Vector2(256,0);
					new_grid = new_grid.add(new_pos2);
					
				}
				new_pos = new Vector2(0,256);
				new_grid = new_grid.add(new_pos);
			}
			if(this.bg1Loaded == true){
			this.screen.drawImage(this.bg_layer_1,0,0);
			}
			if(this.bg2Loaded == true){
				//console.log("Wut");
				
				for(var j = -1; (j * 512) < (this.screenSize.y + 1024); j++){
				
				new_grid = new Vector2(this.bg_layer_2_offset+(j*512),380);
				//new_grid = new_grid.add(grid_pos);
					
					this.screen.drawImage(this.bg_layer_2,new_grid.x,new_grid.y);
				}
				
				
			//this.screen.drawImage(this.bg_layer_2,this.bg_layer_2_offset,380);
			}
			if(this.bg3Loaded == true){
				//console.log("Wut");
				
				for(var j = -1; (j * 512) < (this.screenSize.y + 1024); j++){
				
				new_grid = new Vector2(this.bg_layer_3_offset+(j*512),280);
				//new_grid = new_grid.add(grid_pos);
					
					this.screen.drawImage(this.bg_layer_3,new_grid.x,new_grid.y);
				}
				
				
			//this.screen.drawImage(this.bg_layer_2,this.bg_layer_2_offset,380);
			}
		}
	}
		
		// A useful little object I made that got thrown to the way side 
		// when I realized how gimped it was going to be without 
		// all the cool things C++/c#/Java could do for it.
	function Vector2(x,y)
	{
		this.x = x;
		this.y= y;
	};
	
	Vector2.prototype = {
		add:function( oVector2){
			var new_x = this.x + oVector2.x;
			var new_y = this.y + oVector2.y;
			var ret_Vec = new Vector2(new_x, new_y );
			return ret_Vec;
		},
		
		subtract:function( oVector2){
			var new_x = this.x - oVector2.x;
			var new_y = this.y - oVector2.y;
			var ret_Vec = new Vector2(new_x, new_y);
			return ret_Vec;
		},
		
		multiply:function( oVector2){
			var new_x = this.x * oVector2.x;
			var new_y = this.y * oVector2.y;
			var ret_Vec = new Vector2(new_x, new_y);
			return ret_Vec;
			
		},
		copyVector:function(){
			var new_x = this.x;
			var new_y = this.y;
			var ret_Vec = new Vector2(new_x, new_y);
			return ret_Vec;
		}
	}
	
	// this... this poor thing got completely forgotten.... I need to remove it.
	function gameObject(x,y)
	{
		
		this.position = new Vector2(x,y);
			
	};
	

	
	function animator(_tex,_c_animation){
		this.texture = _tex;
		this.current_animation = _c_animation;
		this.current_frame = 0;
		this.max_frames = this.current_animation.animation_frames.length - 1;
		this.current_speed = this.current_animation.anim_speed;
		this.animation_loops = this.current_animation.anim_loops;
		this.loop_count = 0;
		this.loop_count_max = this.current_animation.anim_loop_times;
		this.anim_transition = this.current_animation.anim_transition;
	}
	animator.prototype = {
		draw: function(x,y,screen,screenSize, camera)
		{
			
			
			
			var screen_pos_x = (x - camera.camera_position.x);
			var screen_pos_y = (y - camera.camera_position.y);
			
			var anim_frame = this.current_animation.animation_frames[Math.floor(this.current_frame)];
			if( screen_pos_x > -300 && screen_pos_x < (screenSize.x +300) && screen_pos_y > -300 && screen_pos_y < (screenSize.y +300)){
				//console.log(Math.floor(this.current_frame));
				//console.log(anim_frame.x);
				
				screen.drawImage(this.texture,
								anim_frame.x,
								anim_frame.y,
								anim_frame.width,
								anim_frame.height,
								screen_pos_x+anim_frame.x_offset,screen_pos_y+anim_frame.y_offset,anim_frame.width,anim_frame.height);
								
								
								//console.log(this.current_animation.animation_frames[Math.floor(this.current_frame)].x);
			}
			//console.log(this.current_frame);
			
			
			
			
			
		},
		update: function(){
			
			var anim_change_flag = false;
		
			
			this.current_frame += this.current_speed;
			
			if(Math.floor(this.current_frame) > this.max_frames){
				//console.log("is this running 1");
				if(this.animation_loops == true){
					//console.log("is this running 2");
					if(this.loop_count_max == -1 || this.loop_count < this.loop_count_max){
						this.current_frame = 0;
						//console.log("is this running 3");
						if(this.loop_count_max != -1)this.loop_count++;
					}else
					{	
						if(this.anim_transition != null)
						{
							this.current_animation = this.anim_transition;
							anim_change_flag = true;
							
						}
						this.current_frame = this.max_frames;
					}
				}
			}else {
				
			}
			
			if(anim_change_flag == true)
			{
				
				this.current_frame = 0;
				this.max_frames = this.current_animation.animation_frames.length - 1;
				this.current_speed = this.current_animation.anim_speed;
				this.anim_loops = this.current_animation.anim_loops;
				this.loop_count = 0;
				this.loop_count_max = this.current_animation.anim_loop_times;
				this.anim_transition = this.current_animation.anim_transition;
				anim_change_flag = false;
			}
		},
		changeAnim: function(new_anim)
		{
			this.current_animation = new_anim;
			this.current_frame = 0;
			this.max_frames = this.current_animation.animation_frames.length - 1;
			this.current_speed = this.current_animation.anim_speed;
			this.anim_loops = this.current_animation.anim_loops;
			this.loop_count = 0;
			this.loop_count_max = this.current_animation.anim_loop_times;
			this.anim_transition = this.current_animation.anim_transition;
			
		}
	}
	
	function animation(a_loop, a_loop_times, a_speed, a_trans){
		this.animation_frames = [];
		this.anim_loops = a_loop;
		this.anim_loop_times = a_loop_times;
		this.anim_speed = a_speed;
		this.anim_transition = a_trans;
	}
	animation.prototype = {
		addFrame:function(x,y,w,h,x_off, y_off){
			var frame = new anim_frame(x,y,w,h,x_off, y_off);
			this.animation_frames.push(frame);
		}
	}
	
	
	
	function anim_frame(_x,_y,_w,_h,x_off,y_off)
	{
		// coordinate of the texture to start clipping
		this.x = _x;
		this.y = _y;
		
		//the dimensions of the frame.
		this.width = _w;
		this.height = _h;
		
		//the offset to the player character's x;
		this.x_offset = x_off;
		this.y_offset = y_off;
	}
	
	function audio_controller(can)
	{
		// stuff
		this.music_loop = new Audio('FleshEaters.mp3');
		this.music_loop.loop = true;
		this.music_loop.autoplay = true;
		this.music_loop.load();
		
		this.canvas = can;
		
		this.sound_jump = new Audio('Jump.wav');
		this.sound_coin = new Audio('Coin.wav');
		this.sound_hurt = new Audio('Hurt.wav');
		this.sound_power = new Audio('Powerup.wav');
		this.sound_crush = new Audio('Crush.wav');
		var self = this;
		this.canvas.addEventListener('click', function(event) {
			self.music_loop.play();
		}, false);
		
		
		//this.music_loop.play();
		console.log(this.music_loop);
		
	}
	
	audio_controller.prototype = {
		//
		playJump:function()
		{
			this.sound_jump.play();
		},
		playCoin:function()
		{
			this.sound_coin.play();
		},
		playHurt:function()
		{
			this.sound_hurt.play();
		},
		playPower:function()
		{
			this.sound_power.play();
		},
		playCrush:function()
		{
			this.sound_crush.play();
		}
	}
	
	
	
	
	// more of Mary Cooks excellent code. It's effectively the keyboarder object
	// from her Space Invaders example.
	var Keyboarder = function() {
		var keyState = {};
		
		window.onkeydown = function(e) {
			keyState[e.keyCode] = true;
		};
		
		window.onkeyup = function(e) {
			keyState[e.keyCode] = false;
		};
		
		this.isDown = function(keyCode) {
			return keyState[keyCode] === true;
		};
		this.KEYS = {UP: 87, DOWN: 83, LEFT: 65, RIGHT: 68, SPACE: 32, RUN: 74};
	};
	window.onload = function() {
		new Game("screen");
	};
})();